## 2016.9.13 ##
[http://www.360doc.com/content/14/0514/10/13084517_377465379.shtml](http://www.360doc.com/content/14/0514/10/13084517_377465379.shtml "x264编码范例")
### 上午 ###
使用ffmpeg进行编码，每n帧编码一次，然后进行推流，编码中有可能失败，只要有一个失败就不能进行推流，而且推流的速度很慢，NALU大小大的超过10w</br>
本来C++编写的获取摄像头+美颜+编码+推流的程序在获取摄像头视频的时候会崩溃，因为该程序与矫正程序从摄像头获取的都是Mat类型，所以将编码和推流程序移植到矫正显示的代码上，能够成功运行。但是并不能播放推流视频。</br>
该程序每次获取一帧图像并进行编码，然后推流；每次推流一帧大小，每次都是先连接，然后发送再关闭连接。</br>
更改视频分辨率会对程序有影响
### 下午 ###
发现程序运行一段时间之后会中断，注释掉推流的代码部分后，程序每执行一次，内存增长200-300k大小，有内存泄漏问题。</br>
通过对不同代码的注释，查找是哪里的内存未释放掉，最后发现当有这一句的时候，内存不断增长。
<pre><code>x264_picture_alloc(pic_in, X264_CSP_I420, width, height);
</code></pre>
百度搜索到x264\_picture\_alloc函数的代码
<pre><code>
 int x264_picture_alloc( x264_picture_t *pic, int i_csp, int i_width, int i_height )  
{
    //指明被编码图像的类型，有X264_TYPE_AUTO、X264_TYPE_IDR、X264_TYPE_I、X264_TYPE_P、X264_TYPE_BREF、X264_TYPE_B
    //可供选择，初始化为AUTO，说明由x264在编码过程中自行控制。 
    pic->i_type = X264_TYPE_AUTO; 
   
    pic->i_qpplus1 = 0; //强制量化器，此参数减1代表当前画面的量化参数值。  
    pic->img.i_csp = i_csp; //图像颜色空间参数，目前只支持I420/YUV420.  
    pic->img.i_plane = 3; //颜色空间数目，如I420是3  
    pic->img.plane[0] = x264_malloc( 3 * i_width * i_height / 2 );//这一句动态分配了空间，需要释放  
    if( !pic->img.plane[0] )  
        return -1;  
    pic->img.plane[1] = pic->img.plane[0] + i_width * i_height;  
    pic->img.plane[2] = pic->img.plane[1] + i_width * i_height / 4;  
    pic->img.i_stride[0] = i_width;  
    pic->img.i_stride[1] = i_width / 2;  
    pic->img.i_stride[2] = i_width / 2;  
    pic->param = NULL;  
    return 0;  
}
</code></pre>
<pre><code>void *x264_malloc( int i_size )  
{  
    uint8_t *align_buf = NULL;  
#ifdef SYS_MACOSX  
    /* Mac OS X always returns 16 bytes aligned memory */  
    align_buf = malloc( i_size );  
#elif defined( HAVE_MALLOC_H )  
    align_buf = memalign( 16, i_size );  
#else  
    uint8_t *buf = malloc( i_size + 15 + sizeof(void **) + sizeof(int) );返回指向分配域起始地址的指针，buf值为0x00b9dca0  
    if( buf )  
    {  
        align_buf = buf + 15 + sizeof(void **) + sizeof(int);//此处执行完后align_buf后的值为0x00b9dcb7.  
        align_buf -= (intptr_t) align_buf & 15; //typedef  _W64 int    intptr_t;，_W64就是__w64，是为了解决32位与64位编译器的兼容性而设置的关键字   用于指针运算  。此处执行完后align_buf后的值为0x00b9dcb0.  
   
        *( (void **) ( align_buf - sizeof(void **) ) ) = buf;  
        *( (int *) ( align_buf - sizeof(void **) - sizeof(int) ) ) = i_size;  
    }  
#endif  
    if( !align_buf )  
        x264_log( NULL, X264_LOG_ERROR, "malloc of size %d failed/n", i_size );  
    return align_buf;  
} 
</code></pre>
在pic->img.plane[0] = x264\_malloc( 3 * i_width * i\_height / 2 );中申请了内存，但是程序并没有释放掉，所以导致了内存泄漏。</br>
与x264\_picture\_alloc对应的释放函数是x264\_picture\_clean(x264\_picture\_t *pic),用来释放pic中申请的内存</br>
**出现问题**
当使用x264\_picture\_t函数释放内存时，总是在这里中断。</br>
**解决**</br>
原来用法
<pre><code>pic_in->img.plane[0] = yuv_buffer;
pic_in->img.plane[1] = pic_in->img.plane[0] + width * height;
pic_in->img.plane[2] = pic_in->img.plane[1] + width * height
</code></pre>
改成
<pre><code>memcpy(pic_in->img.plane[0], yuvbuffer, width * height);
memcpy(pic_in->img.plane[1], yuvbuffer + width * height, width * height / 4);
memcpy(pic_in->img.plane[2], yuvbuffer + width * height * 5 / 4, width * height / 4);
</code></pre>
成功运行
### 晚上 ###
整理文件夹(今天移动硬盘和球杆到了)
