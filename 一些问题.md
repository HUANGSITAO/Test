# 遇到的一些问题 #
## C语言编写的Dll中函数的名字改变 ##
[http://www.cnblogs.com/cswuyg/archive/2011/09/30/dll.html](http://www.cnblogs.com/cswuyg/archive/2011/09/30/dll.html "导出函数")
<p>在C#中使用C的Dll库时需要使用函数真正的名字,可以通过dllexp.exe软件来得知</p>
<p>在导出C函数的时候不改变名字第一种方法是直接在代码里解决采用extent”c”、_declspec(dllexport)、#pragma comment(linker, "/export:[Exports Name]=[Mangling Name]")，另一种是采用def文件。</p>
## C#调用非托管DLL时出现“尝试读取或写入受保护的内存”,返回值为string类型 ##
<p>近期因为业务需要，找人用易语言定做了一个DLL，里面含用一个输出函数，
我在C#里面用如下方式声明再调用：
<pre><code>[DllImport("etest.dll")]
public static extern string TestFunc1(string param1);

string ret1 = TestFunc1("testparam1");
</code></pre>
有时能调用成功，但大多时候会出现：“尝试读取或写入受保护的内存。这通常指示其他内存已损坏。”
换用StringBuilder类型作为参数和返回类型，也会出现同样的错误，偶尔还会出现“没有足够的内存继续执行程序。”，或者弹出对话框提示“不能分配112字节的椎栈空间”。。。反正全是内存操作方面的错误，我断断续续地调试了两天左右，试了各种类型，连byte[] 也用过，还是出错，
不过以前CSDN上有人评价过我是“偏执狂”，的确没错，我在技术问题上从不轻易妥协，结果终于问题有了一点头绪！
用GOOGLE在CSDN上搜到了这个贴子：http://topic.csdn.net/u/20071223/11/64dd0f4c-aff3-4e07-b662-722ffd2fead4.html，看到一楼有个建议好像不错，于是试了下，果然可以！
代码如下：
<pre><code>[DllImport("etest.dll")]
public static extern IntPtr TestFunc1(IntPtr param1);
IntPtr ptrIn = Marshal.StringToHGlobalAnsi("testparam1");
IntPtr ptrRet = TestFunc1(ptrIn);
string ret2 = Marshal.PtrToStringAnsi(ptrRet);
</code></pre>
具体原理我一时也解释不清楚，似乎是要传指针才可以。我后来试着用Delphi封装了一下这个DLL，参数和返回类型全部用PCHAR，然后在.NET里面调用，仍然报同样的错误，不知道是不是易语言里面的string类型很特殊。。。大家可以发表下看法！
</p>
## WPF窗口之间的通信 ##
<p>主播未登录的时候,界面,主界面上没有声音按钮以及开始直播的按钮(直播画面应该是模糊的),当主播登录,这些按钮显示出来(并且画面变清晰)
只有在主窗口定义了登录界面的对象,主窗口可以得知登录窗口的属性以及事件,但登录界面却不能得到主窗口的一些控件信息等.所以当登录成功时,只有在主窗口才能改变登录后的状态,如按钮显现等.</p>
实现代码:
<pre><code>
事件是在登录之后产生的,所以在Login.xaml.cs中声明一个事件
Public event LoginDelegate LoginEvent;
然后在登录成功后调用这个事件
LoginEvent();
在MainWindow.xaml.cs中
Private Login m_login;//定义登录窗口对象
将登录事件委托给主窗口的函数来改变主窗口的一些控件属性等
m_login.LoginEvent += new LongDelegate(Login);
定义Login函数
Public void Login(){
	登录之后主窗口的变化…
}
</code></pre>
## C#调用libtim.dll ##
<pre><code>
public delegate void CBOnSuccess(IntPtr data);
public delegate void CBOnError(int code, 
[MarshalAs(UnmanagedType.LPArray,SizeConst=30)]string desc, IntPtr data);

[StructLayout(LayoutKind.Sequential)] 
public struct TIMCommCB 
{
    public CBOnSuccess OnSuccess;
    public CBOnError OnError;
    public IntPtr data;
};

</code></pre>
调用TIMLogin程序崩溃</p>
解决办法:
不在C#中对libtim.dll进行引用,而是使用C语言引入libtim.dll写好登录程序在封装成dll</br>
在C#中对新dll进行引用,使用新dll中的借口API,这样能够避免类型转换带来的不必要的麻烦.
再写新的dll库之前需要先在C程序中写好测试代码,以免出现错误,测试代码即C程序实现要做的功能代码.
新dll库:LoginDll.dll
C#测试程序:testLogin
## 在WPF的LiveClient程序中,将LoginDll.dll放到运行目录下,依然提示找不到这个库 ##
因为LoginDll.dll引用了其他的库libtim.dll,所以必须将这个库也放到运行目录下.
## 对 PInvoke 函数的调用导致堆栈不对称问题. ##
添加属性:CallingConvention=CallingConvention.Cdecl
## 返回sig的程序的路径 ##
C:\Users\Administrator\Downloads\tls_sig_api-src.tar.gz等3个文件\tls_sig_api-windows-64\example\cs
## 无法找到***.lib ##
将对应.lib文件复制到VC++目录->库包含的目录中
## “无法启动程序，因为计算机中丢失MSVCP100D.dll”的解决方案 ##
[http://blog.csdn.net/hellousb2010/article/details/38052825](http://blog.csdn.net/hellousb2010/article/details/38052825 "无法启动程序,因为计算机中丢失MSVCP100D.dll")</br>
解决办法:将Demo中的msvcp100d.dll拷贝到项目下或者将msvcp100d.dll拷贝到系统目录下C:\Windows\SysWOW64,如果是32位系统则拷贝到C:\Windows\System32</br>
点击开始菜单-->运行-->输入regsvr32 msvcp100d.dll，回车即可弹出错误提示。</br>
其他解决办法见链接.
